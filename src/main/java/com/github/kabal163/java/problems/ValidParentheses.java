package com.github.kabal163.java.problems;

import java.util.ArrayDeque;
import java.util.Deque;

public class ValidParentheses {

    static final String VALID = "valid";
    static final String INVALID = "invalid";

    public static void main(String[] args) {
        System.out.println("The sequence of '[]' is " + (isValid("[]") ? VALID : INVALID));
        System.out.println("The sequence of '[{]}' is " + (isValid("[{]}") ? VALID : INVALID));
        System.out.println("The sequence of '()[]{}' is " + (isValid("()[]{}") ? VALID : INVALID));
        System.out.println("The sequence of '()[]{}}' is " + (isValid("()[]{}}") ? VALID : INVALID));
    }

    /**
     * <b>Approach</b>
     * <p>
     * Для решения задачи является очевидным, что нам необходимо итерироваться по
     * каждому символу входящей строки. Далее нам необходимо понимать - является ли
     * закрывающая скобка валидной в данной позиции. Я говорю именно про закрывающую,
     * потому что мы не можем делать подобные предположения для открывающей. Открывающая
     * скобка на момент ее проверки всегда является валидной, так как мы пока не знаем,
     * есть у нее пара в виде закрывающей или нет. Возвращаясь к вопросу - является ли
     * закрывающая скобка валидной. Для того, чтобы это понять, нам необходимо каким-то
     * образом найти ее пару в виде открывающей скобки. Если нашли - все хорошо, если нет,
     * значит считаем, что последовательность невалидна.
     * Остается вопрос - как нам найти пару в виде открывающей скобки, учитывая, что
     * мы имеем несколько видов скобок. Давайте для этого представим такую последовательность:
     * {@code '([{}])'}. Как мы уже поняли, мы не проверяем на валидность открывающие скобки.
     * Мы должны их куда-то сохранять для того, чтобы потом сопоставлять с соответствующей
     * закрывающей. При этом мы хотим, что порядок, в котором мы их сохраняем учитывался.
     * Давайте представим, что мы начинаем итерироваться по символам этой строки.
     * Первый символ, который мы видим это открывающая круглая скобка {@code '('}. Мы не проверяем
     * ее, однако, сохраняем куда-то, чтобы потом сопоставить с закрывающей. Идем дальше. Теперь
     * текущий символ это открывающая квадратная скобка {@code '['}. Проделываем с ней тоже самое.
     * Идем дальше, видим открывающую фигурную скобку <code>'{'</code>. Проделываем с ней тоже самое.
     * Наконец мы дошли до первой закрывающей скобки - закрывающая фигурная скобка <code>'}'</code>.
     * Вот ее и нужно проверять. Для этого мы обращаемся к структуре данных, в которую до этого
     * мы сохраняли все наши открывающие скобки. Напомню, что структура учитывает порядок,
     * в котором мы их сохраняли. И теперь мы начинаем вытаскивать от туда наши открывающие
     * скобки, но с конца. Таким образом, мы вытащим открывающую фигурную скобку <code>'{}</code>,
     * так как ее мы положили самое последней. Теперь мы можем проверить - является ли данная
     * открывающая скобка валидной парой для текущей закрывающей. Мы видим, что да. Удаляем
     * открывающую фигурную скобку из структуры данных где она до этого была. Теперь последней
     * в этой структуре является открывающая квадратная скобка {@code '['}. Движемся дальше и
     * перед нами закрывающая квадратная скобка {@code ']'}. Проделываем все тоже самое -
     * достаем последнюю сохраненную открывающую скобку (напоминаю, что теперь это {@code '['},
     * так как фигурную мы удалили оттуда после успешного сопоставления). Пытаемся сопоставить
     * ее с закрывающей - все хорошо. Значит удаляем из структуры {@code '['} и движемся дальше.
     * Проделываем все тоже самое с последней парой. Если в результате наша с вами структура
     * стала пустой - значит мы нашли пару для каждой открывающей скобки.
     * <p>
     * <b>Stack</b>
     * <p>
     * Структура о которой идет речь называется stack. Stack можно представлять как стопку
     * тарелок - сначала ставим первую тарелку, на нее ставим вторую и так далее. А когда
     * начинаем что-то доставать из стопки - мы начинаем сверху (как бы с конца). Это
     * наглядно демонстрирует принцип работы LIFO - last in first out (последним зашел,
     * первым вышел). И действительно - последняя тарелка, которую мы ставим на вершину
     * стопки появляется в стэке последней. И при этом, когда мы начнем разгребать нашу
     * стопу эта тарелка уйдет из него первой. Отсюда и "последним зашел, первым вышел".
     *
     * @see <a href="https://javarush.com/groups/posts/2321-strukturih-dannihkh--stek-i-ocheredjh">Stack and Queue</a>
     */
    public static boolean isValid(String s) {
        int len = s.length();
        if (len % 2 == 1) {
            return false;
        }
        Deque<Character> stack = new ArrayDeque<>();

        for (char current : s.toCharArray()) {
            if (current == '(' || current == '{' || current == '[') {
                stack.push(current);
            } else {
                if (stack.isEmpty()) {
                    return false;
                }
                char lastOpen = stack.pop();
                if (lastOpen == '(' && current == ')') {
                    continue;
                }
                if (lastOpen == '{' && current == '}') {
                    continue;
                }
                if (lastOpen == '[' && current == ']') {
                    continue;
                }
                return false;
            }
        }

        return stack.isEmpty();
    }
}
